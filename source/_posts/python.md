---
title：python

date:2025-3-1
---



### 1：

在python中，非零的值都视为true，而0则为False

`if-else` 结构用于在一个条件为真时执行一段代码，如果条件不成立，则执行另一段代码。

`if-elif-else` 结构用于处理多个条件，允许你在多个条件中选择一个进行执行。`elif` 是“else if”的缩写

for -eles一般执行循环语句的结尾，即当循环结束时才会执行eles代码块，但是如果中途出现break语句并触发，则else不会执行，否则执行else

pass语句为占位语句，一般而言当你写了if语句当时下一个代码块暂时不想写时可以用pass语句代替，以此保证代码完整避免出现语法错误

ragen内置函数可以生成一个可迭代的序列，并且帮你遍历一遍，ragen返回的不是列表，而是一个对象（迭代器），这个对象可以按需生成数字等；需用`list(range())`转换为列表

len内置函数获取对象长度

---

a = ['Google', 'Baidu', 'Runoob', 'Taobao', 'QQ']

for i in range(len(a)):

  print(i, len(a[i]))

---

该代码中输出了列表a个元素的长度，但是如果将print（i，len（a【i】））改为print（i，a【i】）则会输出元素**因为len是获取对象的长度，len(a）是获取列表的长度进行循环，比如a的长度是5就是循环5次 **







### 推导式

#### 1.

推导式分为：列表推导式，字典推导式，集合推导式以及生成器推导式；元组推导式

**元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 ()圆括号将各部分括起来，而列表推导式用的是中括号 []，另外元组推导式返回的结果是一个生成器对象**，使用圆括号的推导式实际创建的是生成器表达式（generator），而非严格意义上的元组推导式

推导式非常强大且简洁，可以大大提高代码的可读性和效率，尤其在处理简单的循环和条件判断时非常有用。

列表推导式：

---

squares = [x**2 for x in range(10)] 

print(squares) 

*# 输出：[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]*

---

字典推导式：

---

squares_dict = {x: x**2 for x in range(5)} 

print(squares_dict)

 *# 输出：{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}*

---

集合推导式：

---

even_set = {x for x in range(10) if x % 2 == 0}

 print(even_set) 

*# 输出：{0, 2, 4, 6, 8}*

----

生成器推导式：

---

gen = (x**2 for x in range(10))

for number in gen:   

print(number)

----



### 2.

***迭代器是一种可以逐个访问元素的对象***

**生成器是一种特殊的迭代器，但是他更加简洁且生成器允许你逐个生成数据，并会为你节省内存，因为生成器不会一次性把数据加载到内存中，可以在你需要时才加载下一个数据**

（生成器和普通函数不一样，生成器简单来说就是一个返回迭代器的函数）

迭代器有两个基本的方法：**iter()** 和 **next()**，把一个类作为迭代器使用也需要实现这连个方法，irer()会返回一个特殊的迭代器（本身）；next()会返回下一个迭代器对象

***当我们在 Python 中使用迭代器时，也就是使用next获取下一个元素时；如果迭代器中已经没有更多的元素了，Python 会抛出一个 `StopIteration` 异常，表示迭代已经结束，无法再获取更多的元素。***

（StopIteration` 异常是为了防止无限循环出现的情况）

创建生成器使用yield语句；**每次调用生成器的 **next()** 方法或使用 **for** 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 **yield** 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果**



#### 3.

在python中，数量，元组和字符串是不能修改的对象

在python中如果在**fun(a)** 内部修改 a 的值，则是新生成一个 a 的对象。

##### 调用函数

四个知识

1.必须参数：必须以正确的顺序传入函数，调用的数量必须与声明的一致

2.关键字参数：函数调用时使用关键字来确定传入参数值

3.默认参数：调用函数时，如果没有进行传递参数，则会使用默认参数

4.不定长参数：当你需要的函数比当初声明的要更多参数时，这些参数叫做不定长参数

#### 装饰器

装饰器通过 **@** 符号应用在函数定义之前

---

@time_logger
def target_function():
    pass

---



装饰器允许你动态的修改函数和类

装饰器的语法使用 **@decorator_name** 来应用在函数或方法上。

装饰其本身也是函数，通过接受一个函数作为参数，来修改原来的函数

 **@staticmethod** 和 **@classmethod**，用于定义静态方法和类方法。

装饰器在接受一个函数并修改后会返回一个新的函数，这个函数和自己定义的函数有区别，也被称为包装函数，这个函数可以理解为接收函数的增强版

装饰器可以修改原函数传入的参数，也可以在函数执行前后修改改函数的行为，并处理原函数的异常处理行为，修改返回值；装饰器也可以接受参数

（装饰器尽可能会保存原函数的核心功能，确保原函数的行为不会被破坏）

**类装饰器**

---



stack=[]

stack.append(3)

stack.append(5)

stack.append(9)

print (stack)

abb=stack

stack.pop(2)**此处（）里加索引，会不加，默认去除最后一个元素**

print(abb)



#### 队列与栈

出栈取最后一个元素，出队则是第一个元素

| 特性     | 栈（Stack）                | 队列（Queue）                    |
| -------- | -------------------------- | -------------------------------- |
| 存取顺序 | 后进先出（LIFO）           | 先进先出（FIFO）                 |
| 基本操作 | 压栈（Push）、弹栈（Pop）  | 入队（Enqueue）、出队（Dequeue） |
| 常见应用 | 函数调用、回溯、表达式求值 | 任务调度、广度优先搜索、消息队列 |
| 类比     | 叠起来的盘子               | 排队的人                         |

元组不可变，若元组的成员可变类型，则成员可编辑:意思是元组不可变的是结构，但是元组里面的可变类型成员可以被编辑

#### 异常处理

try和except，除此之外还可以加一个else，但是else要放在except后

除此之外还有一个try和finally的语句；这个语句中finally无论有无异常都会执行最后的代码

(try下代码属于测试能不能跑，类似判断，else则是代码测试没有异常时执行)

![img](https://www.runoob.com/wp-content/uploads/2019/07/try_except_else_finally.png)

try 语句中判断文件是否可以打开，如果打开文件时正常的没有发生异常则执行 else 部分的语句***else语句要放在trc里面，避免异常***

异常处理不是只处理发生在trc里面的，还可以处理函数的异常，间接函数也行



异常处理中还可以使用raise语句抛出一个指定异常



---

x = 10
if x > 5:
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))

---



#### 命名空间和作用域

命名空间可以避免项目中重名，因为每个命名空间是独立互不干扰的，在同一命名空间中不能重名，但是不在同一命名空间则可以

命名空间分为，python自带的内置空间和模块的全局以及函数的局部空间

当作用域中的对象执行完时，命名空间结束

作用域可以直接访问命名空间的内容

python中命名空间大部分通过字典实现

四种作用域：L：局部    G：全局变量    B：内置    E：嵌套函数（比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal ）

作用域查找顺序：L,E,G,B

### 总结

- **全局变量**在函数外部定义，可以在整个文件中访问。

- **局部变量**在函数内部定义，只能在函数内访问。

- 使用 `global` 可以在函数中修改全局变量。

- 使用 `nonlocal` 可以在嵌套函数中修改外部函数的变量。

  







del:关键字，删除对象，变量，数据结构里的元素和属性

def：定义函数

as：`as` 是一个关键字，用来为导入的模块、函数或类指定一个别名

import：可以导入模块还可以导入文件与标准库

impot和as可以结合使用，使得代码简洁，比如 **imort  math  as  m**这行代码表示导入模块math并将其命名为m

init：特殊的方法，构造函数
