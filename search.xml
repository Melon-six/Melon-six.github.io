<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>异步请求</title>
      <link href="/2025/03/04/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"/>
      <url>/2025/03/04/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h2 id="tetle：python2"><a href="#tetle：python2" class="headerlink" title="tetle：python2"></a>tetle：python2</h2><h4 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h4><ul><li>发送请求时，程序不会等待响应，而是回直接返回继续执行其他任务，当请求先赢回来时，程序会收到回调通知来处理这个响应</li><li>使用aiohttp和asyncio来实现异步请求</li><li>async用于定义异步函数，表示改函数为协程函数（<strong>协程函数是可以暂停和恢复的程序</strong>）</li><li>await用于等等异步操作完成，当异步程序遇到await时会暂停等待await后面操作完成，不会影响其他异步执行</li><li>asyncio是标准库，用于事件的循环实现，通过asyncio来启动事件循环</li></ul><h4 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h4><ul><li>发送HTTP请求</li><li>解析HTML内容</li><li>提取数据</li><li>储存数据</li></ul><p>使用beautifulsoup库来提取网页数据，对于html和xml文件非常实用</p><p>如果发生中文乱码问题可以通过chardet来自动检测编码，在知道编码的情况下可以通过response.encoding&#x3D;‘  ’来设置</p><p>查找标签：通过find()和find-all（）方法，find返回一个匹配标签，但是find-all返回所有匹配标签</p><p>通过grt-text（）方法查看标签文本内容</p><p>还可以通过parent和children属性来访问父与子标签</p><p>还可以通过传递属性来查找所有具有特定属性的标签</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一、官方核心库</title>
      <link href="/2025/03/03/%E4%B8%80%E3%80%81%E5%AE%98%E6%96%B9%E6%A0%B8%E5%BF%83%E5%BA%93/"/>
      <url>/2025/03/03/%E4%B8%80%E3%80%81%E5%AE%98%E6%96%B9%E6%A0%B8%E5%BF%83%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下是 Kotlin 生态中常用的核心依赖库及其官方学习地址，分类整理供参考：</p><hr><h3 id="一、官方核心库"><a href="#一、官方核心库" class="headerlink" title="一、官方核心库"></a>一、官方核心库</h3><table><thead><tr><th align="left">库名称</th><th align="left">用途</th><th align="left">官方地址</th></tr></thead><tbody><tr><td align="left"><strong>Kotlin Standard Library</strong></td><td align="left">标准库（集合、扩展函数等）</td><td align="left"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/" target="_blank" rel="noopener">kotlinlang.org&#x2F;docs&#x2F;reference</a></td></tr><tr><td align="left"><strong>Kotlin Coroutines</strong></td><td align="left">协程（异步编程）</td><td align="left"><a href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="noopener">github.com&#x2F;Kotlin&#x2F;kotlinx.coroutines</a></td></tr><tr><td align="left"><strong>Kotlin Serialization</strong></td><td align="left">多平台数据序列化</td><td align="left"><a href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noopener">github.com&#x2F;Kotlin&#x2F;kotlinx.serialization</a></td></tr></tbody></table><hr><h3 id="二、Android开发"><a href="#二、Android开发" class="headerlink" title="二、Android开发"></a>二、Android开发</h3><table><thead><tr><th align="left">库名称</th><th align="left">用途</th><th align="left">官方地址</th></tr></thead><tbody><tr><td align="left"><strong>Android Jetpack</strong></td><td align="left">官方组件库</td><td align="left"><a href="https://developer.android.com/jetpack" target="_blank" rel="noopener">developer.android.com&#x2F;jetpack</a></td></tr><tr><td align="left"><strong>Compose</strong></td><td align="left">声明式UI框架</td><td align="left"><a href="https://developer.android.com/jetpack/compose" target="_blank" rel="noopener">developer.android.com&#x2F;jetpack&#x2F;compose</a></td></tr><tr><td align="left"><strong>Coil</strong></td><td align="left">图片加载库</td><td align="left"><a href="https://coil-kt.github.io/coil/" target="_blank" rel="noopener">coil-kt.github.io&#x2F;coil</a></td></tr><tr><td align="left"><strong>Room</strong></td><td align="left">数据库ORM</td><td align="left"><a href="https://developer.android.com/training/data-storage/room" target="_blank" rel="noopener">developer.android.com&#x2F;training&#x2F;data-storage&#x2F;room</a></td></tr></tbody></table><hr><h3 id="三、异步-响应式编程"><a href="#三、异步-响应式编程" class="headerlink" title="三、异步&#x2F;响应式编程"></a>三、异步&#x2F;响应式编程</h3><table><thead><tr><th align="left">库名称</th><th align="left">特点</th><th align="left">官方地址</th></tr></thead><tbody><tr><td align="left"><strong>Flow</strong></td><td align="left">冷数据流处理</td><td align="left"><a href="https://kotlinlang.org/docs/flow.html" target="_blank" rel="noopener">kotlinlang.org&#x2F;docs&#x2F;flow</a></td></tr><tr><td align="left"><strong>RxKotlin</strong></td><td align="left">ReactiveX扩展</td><td align="left"><a href="https://github.com/ReactiveX/RxKotlin" target="_blank" rel="noopener">github.com&#x2F;ReactiveX&#x2F;RxKotlin</a></td></tr><tr><td align="left"><strong>Channel</strong></td><td align="left">协程通信管道</td><td align="left"><a href="https://kotlinlang.org/docs/channels.html" target="_blank" rel="noopener">kotlinlang.org&#x2F;docs&#x2F;channels</a></td></tr></tbody></table><hr><h3 id="四、依赖注入"><a href="#四、依赖注入" class="headerlink" title="四、依赖注入"></a>四、依赖注入</h3><table><thead><tr><th align="left">库名称</th><th align="left">特点</th><th align="left">官方地址</th></tr></thead><tbody><tr><td align="left"><strong>Koin</strong></td><td align="left">轻量级DI框架</td><td align="left"><a href="https://insert-koin.io/" target="_blank" rel="noopener">insert-koin.io</a></td></tr><tr><td align="left"><strong>Dagger Hilt</strong></td><td align="left">官方推荐DI方案</td><td align="left"><a href="https://dagger.dev/hilt/" target="_blank" rel="noopener">dagger.dev&#x2F;hilt</a></td></tr></tbody></table><hr><h3 id="五、网络请求"><a href="#五、网络请求" class="headerlink" title="五、网络请求"></a>五、网络请求</h3><table><thead><tr><th align="left">库名称</th><th align="left">协议支持</th><th align="left">官方地址</th></tr></thead><tbody><tr><td align="left"><strong>Ktor Client</strong></td><td align="left">多平台HTTP客户端</td><td align="left"><a href="https://ktor.io/docs/client.html" target="_blank" rel="noopener">ktor.io&#x2F;clients</a></td></tr><tr><td align="left"><strong>Retrofit</strong></td><td align="left">REST API封装</td><td align="left"><a href="https://square.github.io/retrofit/" target="_blank" rel="noopener">square.github.io&#x2F;retrofit</a></td></tr></tbody></table><hr><h3 id="六、跨平台开发"><a href="#六、跨平台开发" class="headerlink" title="六、跨平台开发"></a>六、跨平台开发</h3><table><thead><tr><th align="left">库名称</th><th align="left">平台支持</th><th align="left">官方地址</th></tr></thead><tbody><tr><td align="left"><strong>KMM (Kotlin Multiplatform Mobile)</strong></td><td align="left">iOS&#x2F;Android共享代码</td><td align="left"><a href="https://kotlinlang.org/lp/mobile/" target="_blank" rel="noopener">kotlinlang.org&#x2F;lp&#x2F;mobile</a></td></tr><tr><td align="left"><strong>Compose Multiplatform</strong></td><td align="left">跨平台UI框架</td><td align="left"><a href="https://www.jetbrains.com/lp/compose-mpp/" target="_blank" rel="noopener">www.jetbrains.com/lp/compose-mpp</a></td></tr></tbody></table><hr><h3 id="七、测试相关"><a href="#七、测试相关" class="headerlink" title="七、测试相关"></a>七、测试相关</h3><table><thead><tr><th align="left">库名称</th><th align="left">测试类型</th><th align="left">官方地址</th></tr></thead><tbody><tr><td align="left"><strong>MockK</strong></td><td align="left">Mock测试框架</td><td align="left"><a href="https://mockk.io/" target="_blank" rel="noopener">mockk.io</a></td></tr><tr><td align="left"><strong>Kotest</strong></td><td align="left">多功能测试框架</td><td align="left"><a href="https://kotest.io/" target="_blank" rel="noopener">kotest.io</a></td></tr><tr><td align="left"><strong>Turbine</strong></td><td align="left">Flow测试工具</td><td align="left"><a href="https://github.com/cashapp/turbine" target="_blank" rel="noopener">github.com&#x2F;cashapp&#x2F;turbine</a></td></tr></tbody></table><hr><h3 id="八、实用工具库"><a href="#八、实用工具库" class="headerlink" title="八、实用工具库"></a>八、实用工具库</h3><table><thead><tr><th align="left">库名称</th><th align="left">功能</th><th align="left">官方地址</th></tr></thead><tbody><tr><td align="left"><strong>Exposed</strong></td><td align="left">SQL DSL &amp; ORM</td><td align="left"><a href="https://github.com/JetBrains/Exposed" target="_blank" rel="noopener">github.com&#x2F;JetBrains&#x2F;Exposed</a></td></tr><tr><td align="left"><strong>Arrow</strong></td><td align="left">函数式编程工具</td><td align="left"><a href="https://arrow-kt.io/" target="_blank" rel="noopener">arrow-kt.io</a></td></tr><tr><td align="left"><strong>Fuel</strong></td><td align="left">网络请求简化库</td><td align="left"><a href="https://github.com/kittinunf/fuel" target="_blank" rel="noopener">github.com&#x2F;kittinunf&#x2F;fuel</a></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/2025/03/03/SQL/"/>
      <url>/2025/03/03/SQL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h2 id="Tetley：SOLdate：2025-3-3"><a href="#Tetley：SOLdate：2025-3-3" class="headerlink" title="Tetley：SOLdate：2025-3-3"></a>Tetley：SOL<br>date：2025-3-3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># SQL 系统学习笔记</span><br><span class="line"></span><br><span class="line">## 一、SQL基础架构</span><br><span class="line">&#96;&#96;&#96;sql</span><br><span class="line">SELECT [DISTINCT] &lt;字段列表&gt;</span><br><span class="line">FROM &lt;表名&gt;</span><br><span class="line">[WHERE &lt;条件&gt;]</span><br><span class="line">[GROUP BY &lt;分组字段&gt;]</span><br><span class="line">[HAVING &lt;分组条件&gt;]</span><br><span class="line">[ORDER BY &lt;排序字段&gt;]</span><br><span class="line">[LIMIT &lt;数量&gt;];</span><br></pre></td></tr></table></figure><hr><h2 id="二、核心操作分类"><a href="#二、核心操作分类" class="headerlink" title="二、核心操作分类"></a>二、核心操作分类</h2><h3 id="1-DDL（数据定义语言）"><a href="#1-DDL（数据定义语言）" class="headerlink" title="1. DDL（数据定义语言）"></a>1. DDL（数据定义语言）</h3><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">CREATE</td><td align="left">创建数据库&#x2F;表</td><td align="left"><code>CREATE TABLE users (...)</code></td></tr><tr><td align="left">ALTER</td><td align="left">修改表结构</td><td align="left"><code>ALTER TABLE users ADD COLUMN...</code></td></tr><tr><td align="left">DROP</td><td align="left">删除数据库&#x2F;表</td><td align="left"><code>DROP TABLE temp_data</code></td></tr><tr><td align="left">TRUNCATE</td><td align="left">快速清空表数据</td><td align="left"><code>TRUNCATE TABLE logs</code></td></tr></tbody></table><p><strong>表创建示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(50) NOT NULL,</span><br><span class="line">    salary DECIMAL(10,2),</span><br><span class="line">    hire_date DATE DEFAULT CURRENT_DATE,</span><br><span class="line">    INDEX idx_name (name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="2-DML（数据操作语言）"><a href="#2-DML（数据操作语言）" class="headerlink" title="2. DML（数据操作语言）"></a>2. DML（数据操作语言）</h3><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">INSERT</td><td align="left">插入数据</td><td align="left"><code>INSERT INTO users VALUES (...)</code></td></tr><tr><td align="left">UPDATE</td><td align="left">更新记录</td><td align="left"><code>UPDATE products SET price=...</code></td></tr><tr><td align="left">DELETE</td><td align="left">删除记录</td><td align="left"><code>DELETE FROM orders WHERE...</code></td></tr></tbody></table><p><strong>批量插入示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO departments (dept_name, budget)</span><br><span class="line">VALUES </span><br><span class="line">    (&#39;Sales&#39;, 500000),</span><br><span class="line">    (&#39;IT&#39;, 750000),</span><br><span class="line">    (&#39;HR&#39;, 300000);</span><br></pre></td></tr></table></figure><hr><h3 id="3-DQL（数据查询语言）"><a href="#3-DQL（数据查询语言）" class="headerlink" title="3. DQL（数据查询语言）"></a>3. DQL（数据查询语言）</h3><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT product_id AS ID, </span><br><span class="line">       product_name &quot;Product Name&quot;,</span><br><span class="line">       unit_price * 0.9 AS discount_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE category_id &#x3D; 3</span><br><span class="line">   AND stock_quantity &gt; 100;</span><br></pre></td></tr></table></figure><h4 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- JOIN示例</span><br><span class="line">SELECT o.order_id, c.customer_name, SUM(oi.quantity * oi.unit_price) total</span><br><span class="line">FROM orders o</span><br><span class="line">JOIN customers c ON o.customer_id &#x3D; c.customer_id</span><br><span class="line">JOIN order_items oi ON o.order_id &#x3D; oi.order_id</span><br><span class="line">WHERE o.order_date BETWEEN &#39;2023-01-01&#39; AND &#39;2023-12-31&#39;</span><br><span class="line">GROUP BY o.order_id, c.customer_name</span><br><span class="line">HAVING total &gt; 1000</span><br><span class="line">ORDER BY total DESC</span><br><span class="line">LIMIT 10;</span><br></pre></td></tr></table></figure><hr><h2 id="三、关键函数速查"><a href="#三、关键函数速查" class="headerlink" title="三、关键函数速查"></a>三、关键函数速查</h2><h3 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1. 聚合函数"></a>1. 聚合函数</h3><table><thead><tr><th align="left">函数</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">COUNT()</td><td align="left">统计行数</td><td align="left"><code>COUNT(DISTINCT dept)</code></td></tr><tr><td align="left">SUM()</td><td align="left">求和</td><td align="left"><code>SUM(sales_amount)</code></td></tr><tr><td align="left">AVG()</td><td align="left">平均值</td><td align="left"><code>AVG(rating)</code></td></tr><tr><td align="left">MAX&#x2F;MIN()</td><td align="left">最大&#x2F;最小值</td><td align="left"><code>MAX(temperature)</code></td></tr></tbody></table><h3 id="2-字符串函数"><a href="#2-字符串函数" class="headerlink" title="2. 字符串函数"></a>2. 字符串函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(first_name, &#39; &#39;, last_name) AS full_name,</span><br><span class="line">SUBSTRING(phone, 1, 3) AS area_code,</span><br><span class="line">LENGTH(address) AS addr_length,</span><br><span class="line">REPLACE(description, &#39;old&#39;, &#39;new&#39;)</span><br></pre></td></tr></table></figure><h3 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3. 日期函数"></a>3. 日期函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CURRENT_DATE() AS today,</span><br><span class="line">DATE_ADD(hire_date, INTERVAL 1 YEAR) AS anniversary,</span><br><span class="line">DATEDIFF(NOW(), order_date) AS days_passed</span><br></pre></td></tr></table></figure><hr><h2 id="四、高级功能"><a href="#四、高级功能" class="headerlink" title="四、高级功能"></a>四、高级功能</h2><h3 id="1-事务控制"><a href="#1-事务控制" class="headerlink" title="1. 事务控制"></a>1. 事务控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE accounts SET balance &#x3D; balance - 100 WHERE user_id &#x3D; 1;</span><br><span class="line">UPDATE accounts SET balance &#x3D; balance + 100 WHERE user_id &#x3D; 2;</span><br><span class="line">COMMIT;  -- 或 ROLLBACK</span><br></pre></td></tr></table></figure><h3 id="2-窗口函数"><a href="#2-窗口函数" class="headerlink" title="2. 窗口函数"></a>2. 窗口函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    employee_id,</span><br><span class="line">    department_id,</span><br><span class="line">    salary,</span><br><span class="line">    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS dept_rank,</span><br><span class="line">    AVG(salary) OVER (PARTITION BY department_id) AS dept_avg_salary</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><h3 id="3-CTE（公共表表达式）"><a href="#3-CTE（公共表表达式）" class="headerlink" title="3. CTE（公共表表达式）"></a>3. CTE（公共表表达式）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WITH regional_sales AS (</span><br><span class="line">    SELECT region, SUM(amount) total_sales</span><br><span class="line">    FROM orders</span><br><span class="line">    GROUP BY region</span><br><span class="line">)</span><br><span class="line">SELECT region, total_sales</span><br><span class="line">FROM regional_sales</span><br><span class="line">WHERE total_sales &gt; 1000000;</span><br></pre></td></tr></table></figure><hr><h2 id="五、性能优化要点"><a href="#五、性能优化要点" class="headerlink" title="五、性能优化要点"></a>五、性能优化要点</h2><h3 id="1-索引策略"><a href="#1-索引策略" class="headerlink" title="1. 索引策略"></a>1. 索引策略</h3><ul><li>为WHERE&#x2F;JOIN&#x2F;ORDER BY字段创建索引</li><li>避免过度索引（写操作性能影响）</li><li>使用复合索引时注意字段顺序</li></ul><h3 id="2-查询优化"><a href="#2-查询优化" class="headerlink" title="2. 查询优化"></a>2. 查询优化</h3><ul><li>避免使用<code>SELECT *</code></li><li>慎用<code>LIKE &#39;%前缀%&#39;</code></li><li>合理使用EXPLAIN分析执行计划</li><li>注意隐式类型转换</li></ul><h3 id="3-设计规范"><a href="#3-设计规范" class="headerlink" title="3. 设计规范"></a>3. 设计规范</h3><ul><li>使用合适的字段类型（如INT vs VARCHAR）</li><li>遵循数据库范式（但不要过度设计）</li><li>建立有效的外键约束</li><li>定期进行表维护（OPTIMIZE TABLE）</li></ul><hr><h2 id="六、安全最佳实践"><a href="#六、安全最佳实践" class="headerlink" title="六、安全最佳实践"></a>六、安全最佳实践</h2><ol><li><p>使用预处理语句防止SQL注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Python示例</span><br><span class="line">cursor.execute(&quot;SELECT * FROM users WHERE id &#x3D; %s&quot;, (user_id,))</span><br></pre></td></tr></table></figure></li><li><p>遵循最小权限原则</p></li><li><p>定期备份重要数据</p></li><li><p>敏感数据加密存储</p></li><li><p>审计日志记录</p></li></ol><hr><h2 id="七、不同数据库差异速查"><a href="#七、不同数据库差异速查" class="headerlink" title="七、不同数据库差异速查"></a>七、不同数据库差异速查</h2><table><thead><tr><th align="left">特性</th><th align="left">MySQL</th><th align="left">PostgreSQL</th><th align="left">SQLite</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="left">自增字段</td><td align="left">AUTO_INCREMENT</td><td align="left">SERIAL</td><td align="left">AUTOINCREMENT</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">字符串拼接</td><td align="left">CONCAT()</td><td align="left">&#96;</td><td align="left"></td><td>&#96; 操作符</td><td>&#96;</td><td></td><td>&#96;</td></tr><tr><td align="left">时间类型</td><td align="left">DATETIME</td><td align="left">TIMESTAMP</td><td align="left">TEXT</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">正则表达式</td><td align="left">REGEXP</td><td align="left">~ 操作符</td><td align="left">需扩展</td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python2</title>
      <link href="/2025/03/03/python2/"/>
      <url>/2025/03/03/python2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h2 id="tetle：python2"><a href="#tetle：python2" class="headerlink" title="tetle：python2"></a>tetle：python2</h2><h4 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h4><ul><li>发送请求时，程序不会等待响应，而是回直接返回继续执行其他任务，当请求先赢回来时，程序会收到回调通知来处理这个响应</li><li>使用aiohttp和asyncio来实现异步请求</li><li>async用于定义异步函数，表示改函数为协程函数（<strong>协程函数是可以暂停和恢复的程序</strong>）</li><li>await用于等等异步操作完成，当异步程序遇到await时会暂停等待await后面操作完成，不会影响其他异步执行</li><li>asyncio是标准库，用于事件的循环实现，通过asyncio来启动事件循环</li></ul><h4 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h4><ul><li>发送HTTP请求</li><li>解析HTML内容</li><li>提取数据</li><li>储存数据</li></ul><p>使用beautifulsoup库来提取网页数据，对于html和xml文件非常实用</p><p>如果发生中文乱码问题可以通过chardet来自动检测编码，在知道编码的情况下可以通过response.encoding&#x3D;‘  ’来设置</p><p>查找标签：通过find()和find-all（）方法，find返回一个匹配标签，但是find-all返回所有匹配标签</p><p>通过grt-text（）方法查看标签文本内容</p><p>还可以通过parent和children属性来访问父与子标签</p><p>还可以通过传递属性来查找所有具有特定属性的标签</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python</title>
      <link href="/2025/03/01/python/"/>
      <url>/2025/03/01/python/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>title：python</p><h2 id="date-2025-3-1"><a href="#date-2025-3-1" class="headerlink" title="date:2025-3-1"></a>date:2025-3-1</h2><h3 id="1："><a href="#1：" class="headerlink" title="1："></a>1：</h3><p>在python中，非零的值都视为true，而0则为False</p><p><code>if-else</code> 结构用于在一个条件为真时执行一段代码，如果条件不成立，则执行另一段代码。</p><p><code>if-elif-else</code> 结构用于处理多个条件，允许你在多个条件中选择一个进行执行。<code>elif</code> 是“else if”的缩写</p><p>for -eles一般执行循环语句的结尾，即当循环结束时才会执行eles代码块，但是如果中途出现break语句并触发，则else不会执行，否则执行else</p><p>pass语句为占位语句，一般而言当你写了if语句当时下一个代码块暂时不想写时可以用pass语句代替，以此保证代码完整避免出现语法错误</p><p>ragen内置函数可以生成一个可迭代的序列，并且帮你遍历一遍，ragen返回的不是列表，而是一个对象（迭代器），这个对象可以按需生成数字等；需用<code>list(range())</code>转换为列表</p><p>len内置函数获取对象长度</p><hr><p>a &#x3D; [‘Google’, ‘Baidu’, ‘Runoob’, ‘Taobao’, ‘QQ’]</p><p>for i in range(len(a)):</p><p>  print(i, len(a[i]))</p><hr><p>该代码中输出了列表a个元素的长度，但是如果将print（i，len（a【i】））改为print（i，a【i】）则会输出元素**因为len是获取对象的长度，len(a）是获取列表的长度进行循环，比如a的长度是5就是循环5次 **</p><h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>推导式分为：列表推导式，字典推导式，集合推导式以及生成器推导式；元组推导式</p><p><strong>元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 ()圆括号将各部分括起来，而列表推导式用的是中括号 []，另外元组推导式返回的结果是一个生成器对象</strong>，使用圆括号的推导式实际创建的是生成器表达式（generator），而非严格意义上的元组推导式</p><p>推导式非常强大且简洁，可以大大提高代码的可读性和效率，尤其在处理简单的循环和条件判断时非常有用。</p><p>列表推导式：</p><hr><p>squares &#x3D; [x**2 for x in range(10)] </p><p>print(squares) </p><p><em># 输出：[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</em></p><hr><p>字典推导式：</p><hr><p>squares_dict &#x3D; {x: x**2 for x in range(5)} </p><p>print(squares_dict)</p><p> <em># 输出：{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}</em></p><hr><p>集合推导式：</p><hr><p>even_set &#x3D; {x for x in range(10) if x % 2 &#x3D;&#x3D; 0}</p><p> print(even_set) </p><p><em># 输出：{0, 2, 4, 6, 8}</em></p><hr><p>生成器推导式：</p><hr><p>gen &#x3D; (x**2 for x in range(10))</p><p>for number in gen:   </p><p>print(number)</p><hr><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p><em><strong>迭代器是一种可以逐个访问元素的对象</strong></em></p><p><strong>生成器是一种特殊的迭代器，但是他更加简洁且生成器允许你逐个生成数据，并会为你节省内存，因为生成器不会一次性把数据加载到内存中，可以在你需要时才加载下一个数据</strong></p><p>（生成器和普通函数不一样，生成器简单来说就是一个返回迭代器的函数）</p><p>迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()</strong>，把一个类作为迭代器使用也需要实现这连个方法，irer()会返回一个特殊的迭代器（本身）；next()会返回下一个迭代器对象</p><p><em><strong>当我们在 Python 中使用迭代器时，也就是使用next获取下一个元素时；如果迭代器中已经没有更多的元素了，Python 会抛出一个 <code>StopIteration</code> 异常，表示迭代已经结束，无法再获取更多的元素。</strong></em></p><p>（StopIteration&#96; 异常是为了防止无限循环出现的情况）</p><p>创建生成器使用yield语句；<strong>每次调用生成器的 <strong>next()</strong> 方法或使用 <strong>for</strong> 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 <strong>yield</strong> 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果</strong></p><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>在python中，数量，元组和字符串是不能修改的对象</p><p>在python中如果在<strong>fun(a)</strong> 内部修改 a 的值，则是新生成一个 a 的对象。</p><h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><p>四个知识</p><p>1.必须参数：必须以正确的顺序传入函数，调用的数量必须与声明的一致</p><p>2.关键字参数：函数调用时使用关键字来确定传入参数值</p><p>3.默认参数：调用函数时，如果没有进行传递参数，则会使用默认参数</p><p>4.不定长参数：当你需要的函数比当初声明的要更多参数时，这些参数叫做不定长参数</p><h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>装饰器通过 <strong>@</strong> 符号应用在函数定义之前</p><hr><p>@time_logger<br>def target_function():<br>    pass</p><hr><p>装饰器允许你动态的修改函数和类</p><p>装饰器的语法使用 <strong>@decorator_name</strong> 来应用在函数或方法上。</p><p>装饰其本身也是函数，通过接受一个函数作为参数，来修改原来的函数</p><p> <strong>@staticmethod</strong> 和 <strong>@classmethod</strong>，用于定义静态方法和类方法。</p><p>装饰器在接受一个函数并修改后会返回一个新的函数，这个函数和自己定义的函数有区别，也被称为包装函数，这个函数可以理解为接收函数的增强版</p><p>装饰器可以修改原函数传入的参数，也可以在函数执行前后修改改函数的行为，并处理原函数的异常处理行为，修改返回值；装饰器也可以接受参数</p><p>（装饰器尽可能会保存原函数的核心功能，确保原函数的行为不会被破坏）</p><p><strong>类装饰器</strong></p><hr><p>stack&#x3D;[]</p><p>stack.append(3)</p><p>stack.append(5)</p><p>stack.append(9)</p><p>print (stack)</p><p>abb&#x3D;stack</p><p>stack.pop(2)<strong>此处（）里加索引，会不加，默认去除最后一个元素</strong></p><p>print(abb)</p><h4 id="队列与栈"><a href="#队列与栈" class="headerlink" title="队列与栈"></a>队列与栈</h4><p>出栈取最后一个元素，出队则是第一个元素</p><table><thead><tr><th>特性</th><th>栈（Stack）</th><th>队列（Queue）</th></tr></thead><tbody><tr><td>存取顺序</td><td>后进先出（LIFO）</td><td>先进先出（FIFO）</td></tr><tr><td>基本操作</td><td>压栈（Push）、弹栈（Pop）</td><td>入队（Enqueue）、出队（Dequeue）</td></tr><tr><td>常见应用</td><td>函数调用、回溯、表达式求值</td><td>任务调度、广度优先搜索、消息队列</td></tr><tr><td>类比</td><td>叠起来的盘子</td><td>排队的人</td></tr></tbody></table><p>元组不可变，若元组的成员可变类型，则成员可编辑:意思是元组不可变的是结构，但是元组里面的可变类型成员可以被编辑</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>try和except，除此之外还可以加一个else，但是else要放在except后</p><p>除此之外还有一个try和finally的语句；这个语句中finally无论有无异常都会执行最后的代码</p><p>(try下代码属于测试能不能跑，类似判断，else则是代码测试没有异常时执行)</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/07/try_except_else_finally.png" alt="img"></p><p>try 语句中判断文件是否可以打开，如果打开文件时正常的没有发生异常则执行 else 部分的语句<em><strong>else语句要放在trc里面，避免异常</strong></em></p><p>异常处理不是只处理发生在trc里面的，还可以处理函数的异常，间接函数也行</p><p>异常处理中还可以使用raise语句抛出一个指定异常</p><hr><p>x &#x3D; 10<br>if x &gt; 5:<br>    raise Exception(‘x 不能大于 5。x 的值为: {}’.format(x))</p><hr><h4 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h4><p>命名空间可以避免项目中重名，因为每个命名空间是独立互不干扰的，在同一命名空间中不能重名，但是不在同一命名空间则可以</p><p>命名空间分为，python自带的内置空间和模块的全局以及函数的局部空间</p><p>当作用域中的对象执行完时，命名空间结束</p><p>作用域可以直接访问命名空间的内容</p><p>python中命名空间大部分通过字典实现</p><p>四种作用域：L：局部    G：全局变量    B：内置    E：嵌套函数（比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal ）</p><p>作用域查找顺序：L,E,G,B</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>全局变量</strong>在函数外部定义，可以在整个文件中访问。</p></li><li><p><strong>局部变量</strong>在函数内部定义，只能在函数内访问。</p></li><li><p>使用 <code>global</code> 可以在函数中修改全局变量。</p></li><li><p>使用 <code>nonlocal</code> 可以在嵌套函数中修改外部函数的变量。</p></li></ul><p>del:关键字，删除对象，变量，数据结构里的元素和属性</p><p>def：定义函数</p><p>as：<code>as</code> 是一个关键字，用来为导入的模块、函数或类指定一个别名</p><p>import：可以导入模块还可以导入文件与标准库</p><p>impot和as可以结合使用，使得代码简洁，比如 <strong>imort  math  as  m</strong>这行代码表示导入模块math并将其命名为m</p><p>init：特殊的方法，构造函数</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>越权漏洞</title>
      <link href="/2025/02/28/%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/02/28/%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>data:玄境靶场</p><hr><h2 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h2><h3 id="理解：分为水平越权与垂直越权以及逻辑问题导致的安全隐患，水平越权就是用户之间的权限漏洞，垂直越权则是用户与管理员直接的权限漏洞；逻辑暂时不理解"><a href="#理解：分为水平越权与垂直越权以及逻辑问题导致的安全隐患，水平越权就是用户之间的权限漏洞，垂直越权则是用户与管理员直接的权限漏洞；逻辑暂时不理解" class="headerlink" title="理解：分为水平越权与垂直越权以及逻辑问题导致的安全隐患，水平越权就是用户之间的权限漏洞，垂直越权则是用户与管理员直接的权限漏洞；逻辑暂时不理解"></a>理解：分为水平越权与垂直越权以及逻辑问题导致的安全隐患，水平越权就是用户之间的权限漏洞，垂直越权则是用户与管理员直接的权限漏洞；逻辑暂时不理解</h3><h4 id="1：能够通过抓包直接直接更改自己账户uid"><a href="#1：能够通过抓包直接直接更改自己账户uid" class="headerlink" title="1：能够通过抓包直接直接更改自己账户uid"></a>1：能够通过抓包直接直接更改自己账户uid</h4><h4 id="2：通过抓包发现可以更改用户类型，将自己账户类型更改为管理员（注意看清楚自己越权对象，管理员一般为admin小写）"><a href="#2：通过抓包发现可以更改用户类型，将自己账户类型更改为管理员（注意看清楚自己越权对象，管理员一般为admin小写）" class="headerlink" title="2：通过抓包发现可以更改用户类型，将自己账户类型更改为管理员（注意看清楚自己越权对象，管理员一般为admin小写）"></a>2：通过抓包发现可以更改用户类型，将自己账户类型更改为管理员（注意看清楚自己越权对象，管理员一般为admin小写）</h4><h4 id="3：参数置空"><a href="#3：参数置空" class="headerlink" title="3：参数置空"></a>3：参数置空</h4><h2 id="支付漏洞"><a href="#支付漏洞" class="headerlink" title="支付漏洞"></a>支付漏洞</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>在支付中，前端会向后端传输数据与参数，以便后端返回支付界面或其他，以及进行数据加密</p><h4 id="1：直接修改商品金额"><a href="#1：直接修改商品金额" class="headerlink" title="1：直接修改商品金额"></a>1：直接修改商品金额</h4><h4 id="2：由于后端限制，商品金额不能为负数或者0，修改商品数量与优惠券金额，使得相加为0，从而骗过后端"><a href="#2：由于后端限制，商品金额不能为负数或者0，修改商品数量与优惠券金额，使得相加为0，从而骗过后端" class="headerlink" title="2：由于后端限制，商品金额不能为负数或者0，修改商品数量与优惠券金额，使得相加为0，从而骗过后端"></a>2：由于后端限制，商品金额不能为负数或者0，修改商品数量与优惠券金额，使得相加为0，从而骗过后端</h4><h2 id="登录漏洞"><a href="#登录漏洞" class="headerlink" title="登录漏洞"></a>登录漏洞</h2><h3 id="1：当遇到只能用以及有的账户登录时可以尝试admin等常见账户"><a href="#1：当遇到只能用以及有的账户登录时可以尝试admin等常见账户" class="headerlink" title="1：当遇到只能用以及有的账户登录时可以尝试admin等常见账户"></a>1：当遇到只能用以及有的账户登录时可以尝试admin等常见账户</h3><h4 id="2：可以通过修改返回值来跳过前端验证"><a href="#2：可以通过修改返回值来跳过前端验证" class="headerlink" title="2：可以通过修改返回值来跳过前端验证"></a>2：可以通过修改返回值来跳过前端验证</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>查找qq</title>
      <link href="/2024/12/27/%E6%9F%A5%E6%89%BEqq/"/>
      <url>/2024/12/27/%E6%9F%A5%E6%89%BEqq/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="查找qq"><a href="#查找qq" class="headerlink" title="查找qq"></a>查找qq</h2><p>1.网上搜索（qq）社工库</p><p>2.Q绑在线查询</p><p>3.搜索引擎和又一套语法</p><p>（双引号加qq号）</p><ol start="4"><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>漏洞</title>
      <link href="/2024/12/26/%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/12/26/%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><h3 id="文件下载漏洞"><a href="#文件下载漏洞" class="headerlink" title="文件下载漏洞"></a>文件下载漏洞</h3><p>判断文件是否存在文件下载漏洞：</p><p><strong>1.</strong></p><p>一般链接形式：</p><p>date.php?file&#x3D;</p><p>date.php?path&#x3D;</p><p><strong>2</strong></p><p>包含参数：</p><p>&amp;src&#x3D;</p><p>&amp;ata&#x3D;</p><p>目录穿越:   ..&#x2F;返回上一级目录</p><p>​                    返回根目录多加几个..&#x2F;</p><h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><p>通过获取webshell来控制服务器最快的方法</p><p>webshell木马程序基于http协议来访问控制</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2024/12/26/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2024/12/26/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL注入分为整型和字符型</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透知识（1）</title>
      <link href="/2024/12/26/%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89/"/>
      <url>/2024/12/26/%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>超文本传输协议；默认端口为80，用于从万维网服务器传输超文本到本地浏览器协议，主要用于规定客户端和服务器的数据传输格式</p><p>HTTP请求分为请求报文和响应报文</p><p>请求报文分为：请求行，请求头部，空一行（请求正文即请求体有的请求报文可能没有）</p><p><strong>直接在浏览器的地址栏中输入 URL 时，通常不会携带请求体</strong></p><p>请求行分为三部分：1.请求方法  2.资源地址（资源定位符） 3.HTTP协议和版本号的说明</p><p>请求方法具有：</p><p><strong>1.GET    请求资源</strong></p><p><strong>2.POST    提交资源</strong></p><p>3.Head    获取响应头</p><p><em><strong>4.DELETE    删除资源</strong></em></p><p><em><strong>5.PUT    替换资源</strong></em></p><p>6.OPTLONS     允许客户端查看服务器性能</p><p>7.TRACE    回显服务器寿佛啊的请求，用于测试或诊断</p><h2 id="Fiddler"><a href="#Fiddler" class="headerlink" title="Fiddler"></a>Fiddler</h2><p>可以抓Edge和谷歌浏览器，火狐浏览器需要设置其他东西即可</p><p>不能抓包微信小程序，因为有设置抓不住，app和小程序不一定能抓，现在大部分都有设置防抓</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>查询lP地址</title>
      <link href="/2024/12/24/%E6%9F%A5%E8%AF%A2lP%E5%9C%B0%E5%9D%80/"/>
      <url>/2024/12/24/%E6%9F%A5%E8%AF%A2lP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="查询lP地址"><a href="#查询lP地址" class="headerlink" title="查询lP地址"></a>查询lP地址</h3><h4 id="Windows："><a href="#Windows：" class="headerlink" title="Windows："></a><strong>Windows：</strong></h4><ol><li><p>打开命令提示符（按 <code>Win + R</code>，然后输入 <code>cmd</code>，按回车）。</p></li><li><p>在命令行窗口中，输入以下命令并按回车：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup 网站域名</span><br></pre></td></tr></table></figure><p>例如，要查看 <code>www.example.com</code> 的 IP 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">nslookup www.example.com</span><br></pre></td></tr></table></figure><h3 id="网站数据库"><a href="#网站数据库" class="headerlink" title="网站数据库"></a>网站数据库</h3><p>SQL注入获取信息</p><p>通过开发工具F12获取信息</p><h3 id="查询php版本"><a href="#查询php版本" class="headerlink" title="查询php版本"></a>查询php版本</h3><h4 id="使用-curl-命令查询-HTTP-响应头："><a href="#使用-curl-命令查询-HTTP-响应头：" class="headerlink" title="使用 curl 命令查询 HTTP 响应头："></a>使用 <code>curl</code> 命令查询 HTTP 响应头：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">curl -I http:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2024/12/06/2024-12-06-Java/"/>
      <url>/2024/12/06/2024-12-06-Java/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>jdk也称Java jdk，可以理解为Java的库也就是c语言中的头文件吧可能</p><p>sdk则是Java用用于开发软件所存在的一个概念，可以理解为开发工具</p><p>Java是一门具有面向对象的编程语言，Java性能强支持多线程运行</p><p>Java对大小写敏感，Java的类名开头字母需要大写，如果类名存在多个单词则需要每个单词首字母大写，而方法名则是开头需要小写，但是如果存在多个单词则和类名不一样，后面的需要大写，并且源文件名必须与方法名相同保存并加入Java后缀，否则会编译出错</p><p>java标识符必须以字母或者下划线以及$开头，并且对大小敏感，关键字不能作为标识符</p><p>Java修饰符分为访问控制和非访问控制符</p><p>Java变量分为局部变量和静态变量以及非静态变量</p><p>Java在5.0引入了枚举概念</p><p>Java注释与c语言和c++类似，但是加入了文档注释（文档注释以 &#x2F;** 开始，以 *&#x2F; 结束，通常出现在类、方法、字段等的声明前面，用于生成代码文档，这种注释可以被工具提取并生成 API 文档，如 JavaDoc。）</p><p>java继承有超类与子类俩个概念，被继承者称为超类，继承者则称为子类与派生类</p><p>Java接口则在继承中起作用，主要为为派生类定义需要用到的方法</p><p>java在创建对象时必须要有一个构造方法，一般Java会自动创建一个构造一个方法；<em>构造的方法必须与类名一样且一个类可以有多个构造方法</em></p><p>Java源文件中可以有多个类，但是每个类各不相同并且也不能存在俩个相同的类</p><p>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行；如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面；import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</p><p>Java内部类：在Java类中嵌套另外一个类</p><p>嵌套类分为静态内部类和非静态内部类，内部类可以直接访问外部类属性和方法，静态内部类无法访问外部类的成员，当想要外部类无法访问内部类时可以使用private来修饰也称为内部私有化；静态内部类使用staic关键字定义（静态内部类不用创建外部类来访问，因为可以直接访问）</p><p>Java匿名类是不能有名字的类，它们不能被引用，只能在创建时用 <strong>new</strong> 语句来声明它们；匿名类主要用于继承一个父类和实现一个接口</p><p>Java包用于对类和类的接口进行分类</p><p>Java中import语句用于提供一个合理的路径，使编译器可以找到某个类</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型</p><p>数字类型：byte，shout，int，flout，double，long</p><p>字符类型：char</p><p>布尔类型：boolean（默认值为false）</p><ul><li><code>int</code>, <code>short</code>, <code>long</code>, <code>byte</code> 的默认值是0。</li><li><code>char</code> 的默认值是 <code>\u0000</code>（空字符）。</li><li><code>float</code> 的默认值是 <code>0.0f</code>。</li><li><code>double</code> 的默认值是 <code>0.0d</code>。</li><li><code>boolean</code> 的默认值是 <code>false</code>。</li><li>引用类型（类、接口、数组）的默认值是 <code>null</code>。</li></ul><p>JAVA中还存在另外一种基本类型 void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作</p><h2 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h2><p>**自动类型转化：整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。**转换从低级到高级</p><p><strong>规则</strong>：必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p><p><strong>强制类型转化</strong></p><ol><li>条件是转换的数据类型必须是兼容的。</li><li>格式：(type)value  type是要强制类型转换后的数据类型   实例：</li></ol><p>** 实例**</p><p>public class ForceTransform {    public static void main(String[] args){        int i1 &#x3D; 123;        byte b &#x3D; (byte)i1;&#x2F;&#x2F;强制类型转换为byte        System.out.println(“int强制类型转换为byte后的值等于”+b);    } }</p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int强制类型转换为byte后的值等于123</span><br></pre></td></tr></table></figure><p><strong>隐含强制类型转化</strong></p><ul><li>1、 整数的默认类型是 int。</li><li><ol start="2"><li>小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f</li><li>java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析：</li></ol></li></ul><p>数据类型转换必须满足如下规则：</p><ul><li><ol><li>不能对boolan类型进行类型转换。</li></ol></li><li><ol start="2"><li>不能把对象类型转换成不相关类的对象。</li></ol></li><li><ol start="3"><li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li></ol></li><li><ol start="4"><li>转换过程中可能导致溢出或损失精度，例如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D;128;   </span><br><span class="line">byte b &#x3D; (byte)i;</span><br></pre></td></tr></table></figure><p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p></li><li><ol start="5"><li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(int)23.7 &#x3D;&#x3D; 23;        </span><br><span class="line">(int)-45.89f &#x3D;&#x3D; -45</span><br></pre></td></tr></table></figure></li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul><li>​在Java中，引用类型的变量非常类似于C&#x2F;C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</li><li>​对象、数组都是引用数据类型。</li><li>​所有引用类型的默认值都是null。</li><li>​一个引用变量可以用来引用任何与之兼容的类型。</li><li>​例子：Site site &#x3D; new Site(“Runoob”)。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Java使用变量之前必须声明</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>Java局部变量是在方法、构造函数或块内部声明的变量，Java局部变量使用前必须初始化，否则会无法编译;<em><strong>其作用域限制在声明它的代码块内部</strong></em></p><h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><p>实例变量是在类中声明，但在方法、构造函数或块之外，它们属于类的实例，每个类的实例都有自己的副本；实例变量如果未初始化则会保存为自身的默认值<strong>我们可以通过对象访问实例变量，也可以通过类名访问静态变量</strong></p><h4 id="静态变量或类变量"><a href="#静态变量或类变量" class="headerlink" title="静态变量或类变量"></a>静态变量或类变量</h4><p>使用static关键字声明，属于类但是不是实例，该变量会在类加载时初始化且只初始化一次，所有该类的实例共享一个类变量的值（表示这个静态变量被所有对象共享，并且每次改变会影响到其他对象）<strong>通过类名和实例名访问</strong></p><h4 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h4><p>参数是方法或构造函数声明中的变量，用于接收调用该方法或构造函数时传递的值，*** 参数变量的作用域只限于方法内部***</p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>常量使用final修饰，使用全大写，单词之间下划线隔开</p><p>参数；类名，局部变量；静态变量；实例变量使用驼峰命名法，即小写字母开头，后面为大写字母</p><p>变量名应该具有描述性</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>命名空间</title>
      <link href="/2024/12/04/2024-12-04-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>/2024/12/04/2024-12-04-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>命名空间主要是为了解决同一作用域中定义重复的元素而导致代码混乱，命名空间通过全局作用域分割独立空间来解决以上问题</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>#include&lt;stdio.h&gt;<br>int rand &#x3D; 10;<br>int main()<br>{<br>printf(“%d\n”,rand);<br>return 0;<br>}</p><p>此时正常，当时如果在头文件中加入rand函数所在的头文件就会出现计算机运行程序时找到了两个rand函数，而出现错误</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>定义命名空间时使用namespace，后面接定义空间的名称并且接{}，然后再{}中接空间成员</p><p>命名空间可以嵌套，类似C语言中的循环嵌套，但是命名空间只能在全局范围内定义</p><p>使用命名空间内成语有三种方法</p><p>第一：使用作用域限定符<a><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0LzIzMDJfNzgzOTE3OTUvYXJ0aWNsZS9kZXRhaWxzLzE0MjIzMDkxMQ==">【C++指南】作用域限定符 :: 使用详解_c++ 限定作用域-CSDN博客</span></a></p><p>第二：将命名空间全部展开（cpp using namespace xxx）</p><p>此方法有风险，三思而后行</p><p>第三：将命名空间部分展开（ using XXX :: xxx;）<br>可以在不全部展开的情况下不使用作用域限定符！！！</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>这个概念适用于c++与c#，其他语言部分可用但是不推荐</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>html</title>
      <link href="/2024/12/02/html/"/>
      <url>/2024/12/02/html/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><!DOCTYPE html><p>这句活就是告诉我们使用那个html版本。<br>只需要记住，看到上面这行代码，说明使用的是html5的版本。</p><meta charset = "UTF-8">utf-8是目前最常用的字符集编码方式，其他的还有gb2312(简单中文)，BIG5(繁体中文)，GBK(全部中文字符)，UTF-8(全世界所有国家需要用到的字符！)。这里只需要记录UTF-8。<h1>~<h6>大小依次递减，注意没有<7>啥的，只有这六个！<hr>用与分隔内容<p>属性</p><hr width="400">1.属性采用的是“键值对”的形式，key = "value" 格式(每个键对应着相应的值， 当按下相应的键时， 就会输出相应的结果)2.属性不分先后顺序！3.任何属性都有默认值，忽略该属性则取默认值。4.属性包括在引号里面，无论是单引号还是双引号都可以，但是如果属性本身带有双引号则必须使用单引号<p>class:为html元素定义一个或多个类名（classname）(类名从样式文件引入)<br>id:定义元素的唯一id（id 属性可用于创建一个 HTML 文档书签）<br>style:规定元素的行内样式（inline style）<br>title:描述了元素的额外信息 (作为工具条使用)</p><p>HTML在浏览器当中显示时，会将多余的空白或者空格变为一个空格（即使是<br>换行也是如此</p><p>href和src的区别<br>              href用于 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系<br>              src会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片</p><p>HTML链接属性（使用<a>和</a>标签链接）<br>1、href：定义链接目标</p><p>2、target：定义链接的打开方式<br> blank: 在新窗口或新标签页中打开链接。<br>_self: 在当前窗口或标签页中打开链接（默认）。<br>_parent: 在父框架中打开链接。<br>_top: 在整个窗口中打开链接，取消任何框架。3、rel：定义链接与目标页面的关系</p><p>4、download：提示浏览器下载链接目标而不是导航到该目标</p><p>5、title：定义链接的额外信息，当鼠标悬停在链接上时显示的工具提示</p><p>6、id：用于链接锚点，通常在同一页面中跳转到某个特定位置</p><p>7、hreflang: 指定链接的目标URL的语言</p><p>8、type: 指定链接资源的MIME类型</p><p>9、class: 用于指定元素的类名（CSS中定义）</p><p>10、style: 直接在元素上定义CSS样式</p><p>HTML 链接 -taget属性可以定义被链接的文档在何处显示</p><p>HTML元素</p><head> 元素包含了所有的头部标签元素<title> 元素:定义了浏览器工具栏的标题当网页添加到收藏夹时，显示在收藏夹中的标题显示在搜索引擎结果页面的标题<base> 标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接:]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
